#!/bin/rc
# derived from /sys/src/libc/9syscall/mkfile; see its comments too
niladic = (_NSEC)

		{switch($objtype){
		case mips
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R1, '0(FP)'
			echo MOVW '$'$n, R1
			echo SYSCALL
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'MOVW $-1,R5
				BNE R1,R5,4(PC)
				MOVW a+0(FP),R5
				MOVW R1,0(R5)
				MOVW R1,4(R5)'
			}
			echo RET
		case mips2
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R1, '0(FP)'
			echo MOVW '$'$n, R1
			echo ADD '$4',R29
			echo SYSCALL
			echo ADD '$-4',R29
			echo RET
		case spim
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R1, '0(FP)'
			echo MOVW '$'$n, R1
			echo ADD '$4',R29
			echo SYSCALL
			echo ADD '$-4',R29
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'MOVW $-1,R5
				BNE R1,R5,4(PC)
				MOVW a+0(FP),R5
				MOVW R1,0(R5)
				MOVW R1,4(R5)'
			}
			echo RET
		case 386
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVL '$'$n, AX
			echo INT '$'64
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'CMPL AX,$-1
				JNE 4(PC)
				MOVL a+0(FP),CX
				MOVL AX,0(CX)
				MOVL AX,4(CX)'
			}
			echo RET
		case amd64
			if(~ $i _SEEK)
				echo TEXT __SEEK'(SB)', 1, '$0'
			if not
				echo TEXT $i'(SB)', 1, '$0'
			#
			# For architectures which pass the first argument
			# in a register, if the system call takes no arguments
			# there will be no 'a0+0(FP)' reserved on the stack.
			#
			if(! ~ $i $niladic)
				echo MOVQ RARG, 'a0+0(FP)'
			echo MOVQ '$'$n, RARG
			echo SYSCALL
			echo RET
		case sparc
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R7, '0(FP)'
			echo MOVW '$'$n, R7
			echo TA R0
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'CMP R7,$-1
				BNE 4(PC)
				MOVW a+0(FP),R8
				MOVW R7,0(R8)
				MOVW R7,4(R8)'
			}
			echo RETURN
		case arm
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R0, '0(FP)'
			echo MOVW '$'$n, R0
			echo SWI 0
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'CMP $-1,R0
				BNE 4(PC)
				MOVW a+0(FP),R1
				MOVW R0,0(R1)
				MOVW R0,4(R1)'
			}
			echo RET
		case arm64
			if(~ $i _SEEK)
				echo TEXT __SEEK'(SB)', 1, '$0'
			if not
				echo TEXT $i'(SB)', 1, '$0'
			if(! ~ $i $niladic)
				echo MOV R0, 'a0+0(FP)'
			echo SVC '$'$n
			echo RETURN
		case power
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R3, '0(FP)'
			echo MOVW '$'$n, R3
			echo SYSCALL
			if(~ $i _SEEK || ~ $i _NSEC) {
				echo 'CMP R3,$-1
				BNE 4(PC)
				MOVW a+0(FP),R8
				MOVW R3,0(R8)
				MOVW R3,4(R8)'
			}
			echo RETURN
		case power64
			if(~ $i _SEEK)
				echo TEXT __SEEK'(SB)', 1, '$0'
			if not
				echo TEXT $i'(SB)', 1, '$0'
			if(! ~ $i $niladic)
				echo MOVD R3, '0(FP)'
			echo MOVW '$'$n, R3
			echo SYSCALL
			echo RETURN
		case riscv
			echo TEXT $i'(SB)', 1, '$0'
			echo MOVW R8, '0(FP)'
			echo MOVW '$'$n, R8
			echo ECALL
			if(~ $i _SEEK) {
				echo 'MOVW $-1, R9
				BNE R8, R9, 4(PC)
				MOVW a+0(FP),R9
				MOVW R8,0(R9)
				MOVW R8,4(R9)'
			}
			if(~ $i _NSEC) {
				echo 'MOVW a+0(FP),R10
				MOVW R8,0(R10)
				MOVW R9,4(R10)'
			}
			echo RET
		case riscv64
			if(~ $i _SEEK)
				echo TEXT __SEEK'(SB)', 1, '$0'
			if not
				echo TEXT $i'(SB)', 1, '$0'
			#
			# For architectures which pass the first argument
			# in a register, if the system call takes no arguments
			# there will be no 'a0+0(FP)' reserved on the stack.
			#
			# jc doesn't widen longs to vlongs when pushing them.
			# so we have to be careful here to only push longs
			# for first arguments, where appropriate.
			#
			switch ($i) {
			case _NSEC
				;
			case _BIND _CHDIR _EXEC _EXITS __EXITS _SEGBRK _OPEN _CREATE \
			    _BRK_ _REMOVE _NOTIFY _PIPE _SEEK _SEGDETACH _SEGFREE \
			    _SEGFLUSH _RENDEZVOUS _UNMOUNT _SEMACQUIRE \
			    _SEMRELEASE _ERRSTR _STAT _WSTAT _AWAIT _TSEMACQUIRE
				echo MOV R8, '0(FP)'
			case *
				echo MOVW R8, '0(FP)'
			}
			echo MOV '$'$n, R8
			echo ECALL
			echo RET
		}} > $i.s
		$AS $i.s
