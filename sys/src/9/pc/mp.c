/*
 * multiprocessor (MPS) support
 *
 * interrupt routing will only be as good as the tables generated by the BIOS,
 * except that we can do better for PCI(-E) MSI devices since they bypass
 * the IO-APICs and ACPI.
 */
#include "u.h"
#include "../port/lib.h"
#include "mem.h"
#include "dat.h"
#include "fns.h"
#include "io.h"
#include "ureg.h"
#include "mp.h"
#include "apbootstrap.h"

enum {				/* flags for experiments */
	Expnovectsharing	= 0,
	Expocd			= 0,
	Expdefapic		= 0,
	Expprnochoice		= 0,
	Exptryothervec		= 0,
	Expchkisa		= 0,
};

#define dprint(...)	if(mpdebug) print(__VA_ARGS__); else USED(mpdebug)

typedef struct Buggymsi Buggymsi;
struct Buggymsi {
	ushort	vid;		/* pci vendor id */
	ushort	did;		/* " device " */
};

/* from mpacpi.c */
Apic *bootapic;

int mpdebug = 0;
void (*mpacpifunc)(void);

static PCMP* mppcmp;
static Bus* mpbus;
static Bus* mpbuslast;
static int mpisabus = -1;

extern int i8259elcr;			/* mask of level-triggered interrupts */
Apic mpapic[MaxAPICNO+1];		/* lapics */

static Apic ioapic[MaxAPICNO+1];
static Ref mpvnoref;			/* unique vector assignment */
static int mpmachno;
static Lock mpphysidlock;
static int mpphysid;
static char *msiconf;

static Buggymsi buggymsi[] = {
			/* 951 msi generates lapic errors & spurious intrs */
	Vsamsung, 0xa802, /* Samsung NVMe SSD SM951/PM951 (m.2 via pcie adapter) */
	Vintel, 0x10a4,	/* intel 82571s, from intel erratum 63 */
	Vintel, 0x105e,
	Vintel, 0x107d,	/* intel 82572s, " */
	Vintel, 0x107e,
	Vintel, 0x107f,
	Vintel, 0x10b9,
//	Vmoschip, 0x9904, /* startech PEX4S553B.02010200 4-port serial card */
};

/*
 * these bus names are from the Intel MP spec.
 * the others (not listed) are essentially all obsolete.
 */
static char* buses[] = {		/* indexed by Buses; see io.h */
	"INTERN", "ISA   ", "PCI   ",
	0,
};

/*
 * returning 0 activates the mp architecture.
 * see mp.c's mpinit for related code.
 */
int
mpidentify(void)
{
	char *cp;
	uchar sum;
	PCMP *pcmp;

	if((cp = getconf("*nomp")) != nil && strtol(cp, 0, 0) != 0) {
		print("archmp: *nomp != 0; no lapic use\n");
		return 1;
	}

	/*
	 * Search for an MP configuration table. For now,
	 * don't accept the default configurations (physaddr == 0).
	 * Check for correct signature, calculate the checksum and,
	 * if correct, check the version.
	 * To do: check extended table checksum.
	 */
	if((_mp_ = sigsearch("_MP_")) == 0 || _mp_->physaddr == 0) {
		print("archmp: no mp table\n");
		/* may be a uniprocessor, but probably has a lapic. */
		if (!(m->cpuiddx & Cpuapic))
			return 1;	/* pre-1994 system: no lapic, 1 cpu */
	} else {
		if (0)
			iprint("mp physaddr %#lux\n", _mp_->physaddr);
		pcmp = KADDR(_mp_->physaddr);
		if(memcmp(pcmp, "PCMP", 4) != 0) {
			print("archmp: mp table has bad magic");
			return 1;
		}

		sum = checksum(pcmp, pcmp->length);
		if(sum != 0 || (pcmp->version != 1 && pcmp->version != 4)) {
			print("archmp: bum checksum or mps version\n");
			return 1;	/* bad checksum or wrong mps version */
		}
	}
	if(cpuserver && conf.havetsc)
		archmp.fastclock = tscticks;
	return 0;
}

void
syncclock(void)
{
	uvlong x;

	if(arch->fastclock != tscticks)
		return;

	if(m->machno == 0){
		wrmsr(Msrtsc, 0);
		m->tscticks = 0;
	} else {
		x = MACHP(0)->tscticks;
		/* wait for cpu0's ticks to roll over */
		while(x == MACHP(0)->tscticks)
			;
		wrmsr(Msrtsc, MACHP(0)->tscticks);
		cycles(&m->tscticks);
	}
}

uvlong
tscticks(uvlong *hz)
{
	if(hz != nil)
		*hz = m->cpuhz;

	cycles(&m->tscticks);	/* Uses the rdtsc instruction */
	return m->tscticks;
}

static int
apicset(Apic *apic, int type, int apicno, int flags)
{
	if(apicno > MaxAPICNO)
		return -1;
	apic->type = type;
	apic->apicno = apicno;		/* ultimately comes from acpi */
	apic->flags = flags | PcmpEN | PcmpUsed;
	return 0;
}

static int
mpnewproc0(Apic *apic, int apicno, int flags)
{
	if (apicset(apic, PcmpPROCESSOR, apicno, flags) < 0)
		return -1;
	apic->lintr[1] = apic->lintr[0] = ApicIMASK;
	if(apic->flags & PcmpBP)
		apic->machno = 0;
	else
		apic->machno = ++mpmachno;
	return 0;
}

int
mpnewproc(Apic *apic, int apicno, int flags)
{
	if(apic->flags & PcmpUsed) {
		print("mpnewproc: apic already enabled\n");
		return -1;
	}
	return mpnewproc0(apic, apicno, flags);
}

static Apic*
mkprocessor(PCMPprocessor* p)
{
	int apicno;
	Apic *apic;

	apicno = p->apicno;
	if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
		return nil;
	apic = &mpapic[apicno];
	return mpnewproc0(apic, apicno, p->flags) < 0? nil: apic;
}

static Bus*
mpgetbustype(int type, int busno)
{
	Bus *bus;

	for(bus = mpbus; bus; bus = bus->next)
		if(bus->busno == busno && bus->type == type)
			return bus;
	return 0;
}

static Bus*
addbus(int type, int bno)
{
	Bus *bus;

	if (mpgetbustype(type, bno) != nil)	/* already on mpbus? */
		return nil;

	dprint("new bus %d type %d...", bno, type);
	bus = xalloc(sizeof(Bus));
	if(mpbus)
		mpbuslast->next = bus;
	else
		mpbus = bus;
	mpbuslast = bus;

	bus->type = type;
	bus->busno = bno;
	if(bus->type == BusPCI){
		bus->po = PcmpLOW;
		bus->el = PcmpLEVEL;
	} else if(bus->type == BusISA){		/* default PC bus? */
		bus->po = PcmpHIGH;
		bus->el = PcmpEDGE;
		if(mpisabus != -1)
			print("mkbus: more than one ISA bus\n");
		mpisabus = bus->busno;
	} else {
		bus->po = PcmpHIGH;
		bus->el = PcmpEDGE;
	}
	return bus;
}

void
addabus(int type, int bno)
{
	addbus(type, bno);
}

static Bus*
mkbus(PCMPbus* p)
{
	int i;

	for(i = 0; buses[i]; i++){
		if(strncmp(buses[i], p->string, sizeof(p->string)) == 0)
			break;
	}
	if(buses[i] == 0)
		return 0;
	return addbus(i, p->busno);
}

static Bus*
mpgetbus(int busno)
{
	Bus *bus;

	for(bus = mpbus; bus; bus = bus->next){
		if(bus->busno == busno)
			return bus;
	}
	print("mpgetbus: can't find bus %d\n", busno);

	return 0;
}

static Apic*
mkioapic(PCMPioapic* p)
{
	void *va;
	int apicno;
	Apic *apic;

	apicno = p->apicno;
	if(!(p->flags & PcmpEN) || apicno > MaxAPICNO)
		return 0;

	/*
	 * Map the I/O APIC.
	 */
	if((va = vmap(p->addr, 1024)) == nil)
		return 0;

	apic = &ioapic[apicno];
	apic->type = PcmpIOAPIC;
	apic->apicno = apicno;
	apic->addr = va;
	apic->paddr = p->addr;
	apic->flags = p->flags;

	return apic;
}

static Aintr*
mkiointr(PCMPintr* p)
{
	Bus *bus;
	Aintr *aintr;
	PCMPintr* pcmpintr;

	/*
	 * According to the MultiProcessor Specification, a destination
	 * I/O APIC of 0xFF means the signal is routed to all I/O APICs.
	 * It's unclear how that can possibly be correct so treat it as
	 * an error for now.
	 */
	if(p->apicno == 0xFF)
		return 0;
	if((bus = mpgetbus(p->busno)) == 0)
		return 0;

	aintr = xalloc(sizeof(Aintr));
	aintr->intr = p;

	if(0)
		dprint("mkiointr: type %d intr type %d flags %#o "
			"bus %d irq %d apicno %d intin %d\n",
			p->type, p->intr, p->flags,
			p->busno, p->irq, p->apicno, p->intin);
	/*
	 * Hack for Intel SR1520ML motherboard, which BIOS describes
	 * the i82575 dual ethernet controllers incorrectly.
	 */
	if(mppcmp && memcmp(mppcmp->product, "INTEL   X38MLST     ", 20) == 0){
		if(p->busno == 1 && p->intin == 16 && p->irq == 1){
			pcmpintr = malloc(sizeof(PCMPintr));
			if(pcmpintr == nil)
				panic("mkiointr: no memory");
			memmove(pcmpintr, p, sizeof(PCMPintr));
			print("mkiointr: %20.20s bus %d intin %d irq %d\n",
				(char*)mppcmp->product,
				pcmpintr->busno, pcmpintr->intin,
				pcmpintr->irq);
			pcmpintr->intin = 17;
			aintr->intr = pcmpintr;
		}
	}
	if ((unsigned)p->apicno >= nelem(mpapic))
		panic("mkiointr: apic %d out of range", p->apicno);
	aintr->apic = &ioapic[p->apicno];
	aintr->next = bus->aintr;
	bus->aintr = aintr;

	return aintr;
}

static ulong vecmap[256/BI2WD];

static int
mpintrinit(Bus* bus, PCMPintr* intr, uint vno /* , int irq */)
{
	int el, po;
	uint v, bit;

	/*
	 * Parse an I/O or Local APIC interrupt table entry and
	 * return the encoded vector.
	 */
	v = vno;
	if (v >= 256) {
		print("mpintrinit: vector %d too big\n", v);
		return ApicIMASK;
	}
	bit = 1u << (v%BI2WD);
	if (vecmap[v/BI2WD] & bit) {
		print("mpintrinit: vector %d already assigned\n", v);
		if (Expnovectsharing)
			return ApicIMASK;  /* utterly forbid vector sharing */
	}
	vecmap[v/BI2WD] |= bit;

	po = intr->flags & PcmpPOMASK;
	el = intr->flags & PcmpELMASK;

	switch(intr->intr){

	default:				/* PcmpINT */
		v |= ApicFIXED;			/* no-op */
		break;

	case PcmpNMI:
		v |= ApicNMI;
		po = PcmpHIGH;
		el = PcmpEDGE;
		break;

	case PcmpSMI:
		v |= ApicSMI;
		break;

	case PcmpExtINT:
		v |= ApicExtINT;
		/*
		 * The AMI Goliath doesn't boot successfully with it's LINTR0
		 * entry which decodes to low+level. The PPro manual says ExtINT
		 * should be level, whereas the Pentium is edge. Setting the
		 * Goliath to edge+high seems to cure the problem.  Other PPro
		 * MP tables (e.g. ASUS P/I-P65UP5) have an entry which decodes
		 * to edge+high, so who knows.
		 * Perhaps it would be best just to not set an ExtINT entry at
		 * all, it shouldn't be needed for SMP mode.
		 */
		po = PcmpHIGH;
		el = PcmpEDGE;
		break;
	}

	if(!po)
		po = bus->po;
	if(po == PcmpLOW)
		v |= ApicLOW;
	else if(po != PcmpHIGH){
		print("mpintrinit: bad polarity %#uX\n", po);
		return ApicIMASK;
	}

	if(!el)
		el = bus->el;
	if(el == PcmpLEVEL)
		v |= ApicLEVEL;
	else if(el != PcmpEDGE){
		print("mpintrinit: bad trigger %#uX\n", el);
		return ApicIMASK;
	}

	return v;
}

static int
mklintr(PCMPintr* p)
{
	Apic *apic;
	Bus *bus;
	int intin, v;

	/*
	 * The offsets of vectors for LINT[01] are known to be
	 * 0 and 1 from the local APIC vector space at VectorLAPIC.
	 */
	if((bus = mpgetbus(p->busno)) == 0)
		return 0;
	intin = p->intin;

	/*
	 * Pentium Pros have problems if LINT[01] are set to ExtINT
	 * so just bag it, SMP mode shouldn't need ExtINT anyway.
	 */
	if(p->intr == PcmpExtINT || p->intr == PcmpNMI)
		v = ApicIMASK;
	else
		v = mpintrinit(bus, p, VectorLAPIC+intin); /* ignore p->irq */

	if(p->apicno == 0xFF){
		for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
			if((apic->flags & PcmpEN)
			&& apic->type == PcmpPROCESSOR)
				apic->lintr[intin] = v;
		}
	}
	else{
		if ((unsigned)p->apicno >= nelem(mpapic))
			panic("mklintr: ioapic %d out of range", p->apicno);
		apic = &mpapic[p->apicno];
		if((apic->flags & PcmpEN) && apic->type == PcmpPROCESSOR)
			apic->lintr[intin] = v;
	}

	return v;
}

static void
checkmtrr(void)
{
	int i, vcnt;
	Mach *mach0;

	/*
	 * If there are MTRR registers, snarf them for validation.
	 */
	if(!(m->cpuiddx & Mtrr))
		return;

	rdmsr(MTRRCap, &m->mtrrcap);
	rdmsr(MTRRDefaultType, &m->mtrrdef);
	if(m->mtrrcap & Capfix){
		rdmsr(Msrmtrrfix0, &m->mtrrfix[0]);
		rdmsr(Msrmtrrfix1, &m->mtrrfix[1]);
		rdmsr(Msrmtrrfix2, &m->mtrrfix[2]);
		for(i = 0; i < 8; i++)
			rdmsr(Msrmtrrfix3+i, &m->mtrrfix[(i+3)]);
	}
	vcnt = m->mtrrcap & Capvcnt;
	if(vcnt > nelem(m->mtrrvar))
		vcnt = nelem(m->mtrrvar);
	for(i = 0; i < vcnt; i++)
		/* what about the corresponding mask register? */
		rdmsr(MTRRPhysBase0+2*i, &m->mtrrvar[i]);	

	/*
	 * If not the bootstrap processor, compare.
	 */
	if(m->machno == 0)
		return;

	/* These print on the apu2 */
	mach0 = MACHP(0);
	if(mach0->mtrrcap != m->mtrrcap)
		print("mtrrcap%d: %lluX %lluX\n",
			m->machno, mach0->mtrrcap, m->mtrrcap);
	if(mach0->mtrrdef != m->mtrrdef)
		print("mtrrdef%d: %lluX %lluX\n",
			m->machno, mach0->mtrrdef, m->mtrrdef);
	for(i = 0; i < nelem(m->mtrrfix); i++){
		if(mach0->mtrrfix[i] != m->mtrrfix[i])
			print("mtrrfix%d: i%d: %lluX %lluX\n",
				m->machno, i, mach0->mtrrfix[i], m->mtrrfix[i]);
	}
	for(i = 0; i < vcnt; i++){
		if(mach0->mtrrvar[i] != m->mtrrvar[i])
			print("mtrrvar%d: i%d: %lluX %lluX\n",
				m->machno, i, mach0->mtrrvar[i], m->mtrrvar[i]);
	}
}

/* main function for APs */
static void
squidboy(Apic* apic)
{
//	iprint("Hello Squidboy\n");

	machinit();
	fpsavealloc();
	mmuinit();

	cpuidentify();
	cpuidprint();
	checkmtrr();

	apic->online = 1;
	coherence();

	lapicinit(apic);
	lapiconline();
	syncclock();
	timersinit();

	fpoff();

	lock(&active);
	cpuactive(m->machno);
	unlock(&active);

	while(!active.thunderbirdsarego)
		microdelay(100);

	schedinit();
}

/* start a single cpu corresponding to apic */
static void
mpstartap(Apic* apic)
{
	ulong *apbootp, *pdb, *pte;
	Mach *mach, *mach0;
	int i, machno;
	uchar *p;

	mach0 = MACHP(0);

	/*
	 * Initialise the AP page-tables and Mach structure. The page-tables
	 * are the same as for the bootstrap processor with the exception of
	 * the PTE for the Mach structure.
	 * Xspanalloc will panic if an allocation can't be made.
	 */
	p = xspanalloc(3*BY2PG + MACHSIZE, BY2PG, 0);  /* pdb, pte, mach, gdt */
	pdb = (ulong*)p;
	memmove(pdb, mach0->pdb, BY2PG);
	p += BY2PG;

	/* MACHADDR is the virtual address of every cpu's own Mach */
	if((pte = mmuwalk(pdb, MACHADDR, 1, 0)) == nil) {
		print("mpstartap: cpu%d: 1st lvl mmuwalk of MACHADDR failed\n",
			apic->machno);
		return;
	}
	memmove(p, KADDR(PPN(*pte)), BY2PG);  /* copy page of MACHADDR's pte */
	*pte = PADDR(p)|PTEWRITE|PTEVALID;
	if(mach0->havepge)
		*pte |= PTEGLOBAL;
	p += BY2PG;

	mach = (Mach*)p;
	if((pte = mmuwalk(pdb, MACHADDR, 2, 0)) == nil) {
		print("mpstartap: cpu%d: 2nd lvl mmuwalk of MACHADDR failed\n",
			apic->machno);
		return;
	}
	/* map MACHADDR on this cpu to mach */
	*pte = PADDR(mach)|PTEWRITE|PTEVALID;
	if(mach0->havepge)
		*pte |= PTEGLOBAL;
	p += MACHSIZE;

	machno = apic->machno;
	MACHP(machno) = mach;	/* physical location of this cpu's Mach */
	mach->machno = machno;
	mach->pdb = pdb;
	mach->gdt = (Segdesc*)p;	/* will be filled by mmuinit */

	/*
	 * Tell the AP where its kernel vector and pdb are.
	 * The offsets are known in the AP bootstrap code.
	 */
	apbootp = (ulong*)(APBOOTSTRAP+0x08);
	*apbootp++ = (ulong)squidboy;	/* assembler jumps here eventually */
	*apbootp++ = PADDR(pdb);
	*apbootp = (ulong)apic;

	/*
	 * Universal Startup Algorithm.
	 */
	p = (uchar *)WARMRESET;		/* warm-reset vector */
	*p++ = APBOOTSTRAP-KZERO;
	*p++ = (APBOOTSTRAP-KZERO)>>8;
	i = ((APBOOTSTRAP-KZERO) & ~0xFFFF)/16;
	/* code assumes i==0 */
	if(i != 0)
		print("mp: APBOOTSTRAP > 64K\n");
	*p++ = i;
	*p = i>>8;

	coherence();

	nvramwrite(0x0F, 0x0A);	/* shutdown code: warm reset upon init ipi */
	lapicstartap(apic, APBOOTSTRAP-KZERO);
	for(i = 0; i < 1000; i++){
		if(apic->online)
			break;
		delay(10);
	}
	nvramwrite(0x0F, 0x00);
}

static void
trympacpi(void)
{
	if (mpacpifunc != nil)
		(*mpacpifunc)();
}

/*
 * Run through the MPS table saving information needed for starting
 * application processors and initialising any I/O APICs.  The table
 * is guaranteed to be in order such that only one pass is necessary.
 */
static Apic *
parsemps(PCMP *pcmp, void *va, int *cpusonp)
{
	uchar *e, *p;
	Apic *apic, *bpapic;

	bpapic = nil;
	p = ((uchar*)pcmp)+sizeof(PCMP);
	e = ((uchar*)pcmp)+pcmp->length;
	while(p < e)
		switch(*p){
		default:
			print("mpinit: unknown PCMP type %#ux @ %#p (e-p %ld):",
				*p, p, e-p);
			while(p < e)
				print(" %uX", *p++);
			print("\n");
			vmbotch(Parallels, "your actual MP table garbled");
			break;

		case PcmpPROCESSOR:
			if(apic = mkprocessor((PCMPprocessor*)p)){
				/*
				 * Must take a note of bootstrap processor APIC
				 * now as it will be needed in order to start
				 * the application processors later and there's
				 * no guarantee that the bootstrap processor
				 * appears first in the table before the others.
				 */
				apic->addr = va;
				apic->paddr = pcmp->lapicbase;
				if(apic->flags & PcmpBP)
					bpapic = apic;
				++*cpusonp;
			}
			p += sizeof(PCMPprocessor);
			break;

		case PcmpBUS:
			mkbus((PCMPbus*)p);
			p += sizeof(PCMPbus);
			break;

		case PcmpIOAPIC:
			if(apic = mkioapic((PCMPioapic*)p))
				ioapicinit(apic, ((PCMPioapic*)p)->apicno);
			p += sizeof(PCMPioapic);
			break;

		case PcmpIOINTR:
			mkiointr((PCMPintr*)p);
			p += sizeof(PCMPintr);
			break;

		case PcmpLINTR:
			mklintr((PCMPintr*)p);
			p += sizeof(PCMPintr);
			break;
		}
	return bpapic;
}

static void
mplaunchaps(void)
{
	int ncpu;
	char *cp;
	Apic *apic;

	checkmtrr();

	/*
	 * Initialise the application processors.
	 */
	if(cp = getconf("*ncpu")){
		ncpu = strtol(cp, 0, 0);
		if(ncpu < 1)
			ncpu = 1;
		else if(ncpu > MAXMACH)
			ncpu = MAXMACH;
	}
	else
		ncpu = MAXMACH;
	memmove((void*)APBOOTSTRAP, apbootstrap, sizeof(apbootstrap));
	coherence();		/* make apboot visible to other cpus */

	for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++){
		if(ncpu <= 1)
			break;
		if((apic->flags & (PcmpBP|PcmpEN)) == PcmpEN
		&& apic->type == PcmpPROCESSOR){
			mpstartap(apic);
			conf.nmach++;
			ncpu--;
		}
	}

	/*
	 *  we don't really know the number of processors till
	 *  here.
	 *
	 *  set conf.copymode here if nmach > 1.
	 *  Should look for an ExtINT line and enable it.
	 */
	if(conf.nmach > 1 || cpuisa386()) {
		conf.copymode = 1;
		if (conf.nmach > 1)
			print("\n");	/* terminate "more cpus:" line */
	}
}

/*
 * mostly apic setup, followed by launching the other cpus.
 *
 * see archmp.c's identify for related code.
 */
void
mpinit(void)
{
	int cpuson;
	uintptr lapic;
	PCMP *pcmp;
	PCMPprocessor *pcmpproc;
	Apic *apic, *bpapic;
	void *va;
	static PCMPprocessor fakepcmpproc;

	mpdebug = getconf("*debugmp") != nil;
	i8259init();
	syncclock();

	bpapic = nil;

	if(_mp_ == 0) {
		print("mpinit: no mp table\n");

		/* may be a uniprocessor, but has a lapic unless very old */
		if (!(m->cpuiddx & Cpuapic)) {	/* pre-1994 system? */
			archrevert();		/* stick to the i8259s */
			return;
		}

		lapic = Lapicphys;	/* assume default lapic address */
		pcmpproc = &fakepcmpproc;
		pcmpproc->apicno = lapicid(lapic);
		pcmpproc->flags = PcmpBP | PcmpEN;
		pcmp = nil;		/* unused with fake pcmpproc */
	} else {
		pcmpproc = nil;		/* unused since we have real pcmp */
		pcmp = KADDR(_mp_->physaddr);
		lapic = pcmp->lapicbase;
	}

	/*
	 * Map the local APIC.
	 */
	if((va = vmap((uintptr)lapic, 1024)) == nil) {
		print("mpinit: can't map lapic at %#p\n", lapic);
		archrevert();		/* stick to the i8259s */
		return;
	}
	mppcmp = pcmp;
	if (pcmp == nil) {		/* no mp table? assume uniprocessor */
		if(apic = mkprocessor(pcmpproc)){
			apic->addr = va;
			apic->paddr = (uintptr)lapic;
			bpapic = apic;
		}
	} else {
		cpuson = 0;
		bpapic = parsemps(pcmp, va, &cpuson);
		dprint("mpinit: mp table describes %d cpus\n", cpuson);

		/* always scan ACPI's MADT for any CPUs that MP missed. */
		trympacpi();
	}
	if (bpapic == nil)
		bpapic = bootapic;

	/*
	 * No bootstrap processor, no need to go further.
	 */
	if(bpapic == 0) {
		print("mpinit: no bp apic\n");
		return;
	}
	if(bpapic->addr)
		bpapic->online = 1;

	lapicinit(bpapic);

	/*
	 * These interrupts are local to the processor
	 * and do not appear in the I/O APIC so it is OK
	 * to set them now.
	 */
	intrenable(IrqTIMER, lapicclock, 0, BUSUNKNOWN, "clock");
	intrenable(IrqERROR, lapicerror, 0, BUSUNKNOWN, "lapicerror");
	intrenable(IrqSPURIOUS, lapicspurious, 0, BUSUNKNOWN, "lapicspurious");
	lapiconline();

	mplaunchaps();
}

static int
cputoapic(int cpu)
{
	Apic *apic;

	for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++)
		if(apic->machno == cpu && apic->online)
			return apic->apicno;
	return -1;
}

static int
apictocpu(int apicno)
{
	Apic *apic;

	for(apic = mpapic; apic <= &mpapic[MaxAPICNO]; apic++)
		if(apic->apicno == apicno && apic->online)
			return apic->machno;
	return -1;
}

static uchar
usecpu(Vctl *v, int cpu)
{
	int apic;

	v->cpu = cpu;
	apic = cputoapic(cpu);
	if (apic < 0)
		panic("mpintrcpu: cpu%d lapic not online", cpu);
	return apic;
}

/* call with mpphysidlock held */
static int
nextmpphysid(void)
{
	int i;

	i = mpphysid++;
	if(mpphysid > MaxAPICNO)
		mpphysid = 0;
	return i;
}

/* return apic id of the lapic of the chosen cpu, fill in v->cpu. */
/* experiment: use logical mode and active.machs as bitmap */
static uchar
mpintrcpu(Vctl *v)
{
	int i, noise;
	Apic *ap;

	/*
	 * The bulk of this code was written ~1995, when there was
	 * one architecture and one generation of hardware, the number
	 * of CPUs was up to 4(8) and the choices for interrupt routing
	 * were physical, or flat logical (optionally with lowest
	 * priority interrupt). Logical mode hasn't scaled well with
	 * the increasing number of packages/cores/threads, so the
	 * fall-back is to physical mode, which works across all processor
	 * generations, both AMD and Intel, using the APIC and xAPIC.
	 *
	 * Interrupt routing policy can be set here.
	 * Currently, just assign each interrupt to a different CPU on
	 * a round-robin basis. Some idea of the packages/cores/thread
	 * topology would be useful here, e.g. to not assign interrupts
	 * to more than one thread in a core, or to use a "noise" core.
	 * But, as usual, Intel make that an onerous task.
	 */

	/*
	 * workaround for many-core intel (non-amd) systems:
	 * always use cpu 0 (as a noise core).
	 */
	if(conf.x86type != Amd && conf.nmach > 8)
		return usecpu(v, 0);

	/* on an mp, assign all noisy interrupt sources (usb) to a noise core */
	noise = conf.nmach - 1;
	if (conf.nmach > 1 && strncmp(v->name, "usb", 3) == 0)
		return usecpu(v, noise);

	/* find next online lapic */
	lock(&mpphysidlock);
	do {
		i = nextmpphysid();
		/* this is non-usb, so skip the noise core */
		if(conf.nmach > 1 && mpapic[i].machno == noise)
			i = nextmpphysid();
		ap = &mpapic[i];
	} while (!ap->online);
	unlock(&mpphysidlock);
	v->cpu = ap->machno;
	return ap->apicno;
}

/*
 * With the APIC a unique vector can be assigned to each
 * request to enable an interrupt. There are two reasons this
 * is a good idea:
 * 1) to prevent lost interrupts, no more than 2 interrupts
 *    should be assigned per block of 16 vectors (there is an
 *    in-service entry and a holding entry for each priority
 *    level and there is one priority level per block of 16
 *    interrupts).  This is true even though there is one bit per vector,
 *    not per priority level, in each of the ISR and IRR registers.
 * 2) each input pin on the IOAPIC will receive a different
 *    vector regardless of whether the devices on that pin use
 *    the same IRQ as devices on another pin.
 */
static int
pickapicvec(Vctl *v, int tbdf)
{
	int vno;

	vno = VectorAPIC + (incref(&mpvnoref)-1)*8;
	if(vno > MaxVectorAPIC){
		print("pickapicvec: vno %d too big, irq %d, tbdf %T\n",
			vno, v->irq, tbdf);
		return -1;
	}
	return vno;
}

/*
 * use message-signalled interrupt if available.  msi and msi-x may both
 * be available (e.g. pci-e devices), but only one can be used on a given
 * device.  msi-x seems much more complicated for little benefit.
 */
static int
trymsi(Vctl *v, Pcidev *pcidev)
{
	int vno, ptr, ptrx, pcie;
	Buggymsi *bm;
	Msi msi;

	if (msiconf && strcmp(msiconf, "no") == 0)
		return -1;
	memset(&msi, 0, sizeof msi);
	ptr = pcigetmsi(pcidev, &msi);
	ptrx = pcigetmsixcap(pcidev);
	pcie = pcigetpciecap(pcidev);
	if (ptr == -1) {
		if (ptrx >= 0)
			print("%s: msi-x offered but not msi! using neither\n",
				v->name);
		if (pcie >= 0)
			print("%s: %T: vid %ux did %ux pci-e device NOT "
				"offering msi, but it's required for pci-e!\n",
				v->name, pcidev->tbdf, pcidev->vid, pcidev->did);
		/* else a pci device, so msi not mandatory */
		return -1;		/* sorry, no msi */
	}

	if (msiconf && strcmp(msiconf, "print") == 0) {
		print("%s: %T: vid %ux did %ux offering msi\n",
			v->name, pcidev->tbdf, pcidev->vid, pcidev->did);
		delay(20);
	}
	for (bm = buggymsi; bm < buggymsi + nelem(buggymsi); bm++)
		if (pcidev->vid == bm->vid && pcidev->did == bm->did) {
			print("%s: %T: vid %ux did %ux known to be buggy; "
				"refusing msi\n", v->name, pcidev->tbdf,
				pcidev->vid, pcidev->did);
			return -1;
		}
	vno = pickapicvec(v, pcidev->tbdf);
	if(vno < 0)
		return -1;

	v->ismsi = 1;
	msi.ctl |= Msienable;
	/*
	 * experiment: use logical mode and active.machs as bitmap.
	 * dest id in msi.addr is 8 bits wide.
	 */
	v->lapic = mpintrcpu(v);		/* sets v->cpu too */
	if (v->cpu == -1)
		print("trymsi: cpu not set by mpintrcpu\n");
	if (v->lapic == -1)
		print("trymsi: lapic not set by mpintrcpu\n");
	msi.addr = (uvlong)(uintptr)Lapicphys | v->lapic<<12 | Msirhtocpuid;
	msi.data = Msitrglevel | Msitrglvlassert | Msidlvfixed | vno;
	pcisetmsi(pcidev, &msi);

	dprint("%s: msi enabled at vector %d lapic %d for %T\n",
		v->name, vno, v->lapic, pcidev->tbdf);
	delay(20);
	return vno;
}

/*
 * Called if already enabled. Multifunction devices may share
 * INT[A-D]# so, if already enabled, check the polarity matches
 * and the trigger is level.
 *
 * Should check the devices differ only in the function number,
 * but that can wait for the planned enable/disable rewrite.
 */
static int
ckapiccfg(PCMPintr *p, Vctl *v, Bus *bus, int lo, int tbdf)
{
	int vno, n;

	vno = lo & 0xFF;
	dprint("%s read vector %d apic already configed\n", v->name, vno);
	n = mpintrinit(bus, p, vno);	/* ignore v->irq */
	n |= ApicPHYSICAL;		/* no-op */
	lo &= ~(ApicRemoteIRR|ApicDELIVS);
	if (n == lo && n & ApicLEVEL)
		return vno;
	if (n == lo)
		print("mpmatchintr: shared irq %d apic config wrong, "
			"tbdf %T\n", v->irq, tbdf);
	else
		print("mpmatchintr: shared irq %d apic config wrong, "
			"tbdf %T, got %#8.8uX != want %#8.8uX\n",
			v->irq, tbdf, lo, n);
	return -1;
}

static void
prbrokenmptbl(int tbdf, PCMPintr *p, Apic *apic)
{
	print("mpmatchintr: %T: bios tables lie, nil apic->addr in mps: "
		"apic: %#p type %d apicno %d paddr %#p; "
		"p: busno %d irq %d apicno %d intin %d\n",
		tbdf, apic, apic->type, apic->apicno, apic->paddr,
		p->busno, p->irq, p->apicno, p->intin);
}

static void
prbadmptbl(int tbdf, PCMPintr *p, Apic *apic)
{
	print("mpmatchintr: %T: no mp bus match: ", tbdf);
	if (apic)
		print("apic: %#p type %d apicno %d paddr %#p; ",
			apic, apic->type, apic->apicno, apic->paddr);
	if (p)
		print("p: busno %d irq %d apicno %d intin %d",
			p->busno, p->irq, p->apicno, p->intin);
	print("\n");
}

static void
ioapicredirect(Apic *apic, Vctl *v, int vno, int tbdf, PCMPintr *p, ulong lo)
{
	ulong hi;

	/* update the i/o redirection table */
	if((apic->flags & PcmpEN) && apic->type == PcmpIOAPIC) {
		dprint("%s: i/o apic enabled for irq %d %T\n", v->name, vno, tbdf);
		v->lapic = mpintrcpu(v);		/* sets v->cpu too */
		if (v->cpu == -1)
			print("ioapicredirect: cpu not set by mpintrcpu\n");
		if (v->lapic == -1)
			print("ioapicredirect: lapic not set by mpintrcpu\n");
		hi = v->lapic << 24;
		ioapicrdtw(apic, p->intin, hi, lo);
	} else {
		dprint("%s: apic not enabled for irq %d %T\n", v->name, vno, tbdf);
	}
}

static void
defapic(Apic *apic)
{
	extern ulong *lapicbase;		/* apic.c */

	if (apic->addr == nil)
		if (lapicbase == nil)		/* should never happen */
			print("defapic: lapicbase is nil\n");
		else {
			apic->addr = lapicbase;	
			apic->paddr = Lapicphys;
		}
}

/* try to match the arguments against the MP table and enable the interrupt */
static int
mpmatchintr(Vctl* v, Bus *bus, int tbdf, int irq)
{
	int lo, vno;
	Aintr *aintr;
	Apic *apic;
	PCMPintr *p;

	/*
	 * Find a matching interrupt entry from the list of interrupts
	 * attached to this bus.
	 */
	p = nil;
	apic = nil;
	for(aintr = bus->aintr; aintr; aintr = aintr->next){
		p = aintr->intr;
		apic = aintr->apic;
		if ((p == nil || apic == nil || p->irq == irq) &&
		    (!Expocd || apic->addr != nil))
			break;
		if(Expdefapic && apic->addr == nil) {
			prbrokenmptbl(tbdf, p, apic);
			/* but interrupts are still routed incorrectly. */
			defapic(apic);		/* maybe this will work */
		}
	}
	if (aintr == nil || p == nil || apic == nil) {
		prbadmptbl(tbdf, p, apic);
		return -1;
	}

	/*
	 * Check if already enabled. Multifunction devices may share INT[A-D]#.
	 *
	 * The RDT read here is safe for now as currently interrupts
	 * are never disabled once enabled.
	 */
if (0) print("%T: apic->addr %#p apic->paddr %#p\n", tbdf, apic->addr, apic->paddr);
	defapic(apic);

	v->cpu = apic->machno;
	ioapicrdtr(apic, p->intin, 0, &lo);
	if(!(lo & ApicIMASK)) {		/* already cleared by ioapicrdtw? */
		vno = ckapiccfg(p, v, bus, lo, tbdf);
		if (vno >= 0 || !Exptryothervec)
			return vno;
		/* experiment: else no vec, so try another way */
	}

	if (Expchkisa && bus->type == BusISA)	/* revisit not using this */
		vno = lo & 0xff;
	else
		vno = pickapicvec(v, tbdf);	/* apparently okay for BusISA */
	if(vno < 0)
		return -1;

	/* experiment to try: use logical mode and active.machs as bitmap */
	lo = mpintrinit(bus, p, vno);		/* ignore v->irq */
	if(lo & ApicIMASK)
		return -1;			/* mpintrinit failed */
	ioapicredirect(apic, v, vno, tbdf, p, lo | ApicPHYSICAL);
	return vno;
}

static int
in8259range(int irq)
{
	/* exclude 0, which probably indicates a missing value, not a timer */
	return irq > 0 && irq <= MaxIrqPIC;
}

static int
mpintrenablex(Vctl* v, int tbdf)
{
	int bno, dno, irq, n, type, vno, msi1st;
	char *typenm;
	Bus *bus;
	Pcidev *pcidev;

	/*
	 * Find the bus.
	 */
	type = BUSTYPE(tbdf);
	bno = BUSBNO(tbdf);
	dno = BUSDNO(tbdf);
	if(type == BusISA)
		bno = mpisabus;
	vno = irq = -1;
	pcidev = nil;
	for(bus = mpbus; bus != nil; bus = bus->next)
		if(bus->type == type && bus->busno == bno)
			break;
	if(bus == nil){
		typenm = type < 0 || type >= nelem(buses)? "": buses[type];
		print("mpintrenablex: can't find bus type %d (%s) for irq %d "
			"%s busno %d\n", type, typenm, v->irq, v->name, bno);
		return -1;
	}

	/*
	 * For PCI devices the interrupt pin (INT[ABCD]) and device
	 * number are encoded into the entry irq field, so create something
	 * to match on. The interrupt pin used by the device has to be
	 * obtained from the PCI config space.
	 */
	if(bus->type == BusPCI){
		pcidev = pcimatchtbdf(tbdf);
		if (pcidev == nil)
			print("no pci match for tbdf %T\n", tbdf);
		else if((n = pcicfgr8(pcidev, PciINTP)) != 0)
			irq = (dno<<2)|(n-1);
		else
			print("no pci intp for %T\n", tbdf);
	} else
		irq = v->irq;

	/* prefer msi if possible, unless directed otherwise */
	if (msiconf == nil)
		msiconf = getconf("*msi");
	msi1st = msiconf == nil || strcmp(msiconf, "last") != 0;

	if (pcidev && msi1st)
		vno = trymsi(v, pcidev);
	if (vno < 0)
		vno = mpmatchintr(v, bus, tbdf, irq);
	if (vno < 0 && pcidev && !msi1st)
		vno = trymsi(v, pcidev);
	v->eoi = v->isr = nil;
	if (vno >= 0) {
		v->isr = lapicisr;		/* nop? */
		v->eoi = lapiceoi;
		if (!in8259range(v->irq))
			v->irq = vno;
		if (pcidev && !in8259range(pcidev->intl))
			pcidev->intl = vno;
	}
	if (pcidev)
		if (v->ismsi)
			pcinointrs(pcidev);	/* no legacy pci interrupts */
		else {
			pcimsioff(v, pcidev);  /* make sure msi is really off */
			pciintrs(pcidev);
		}
	return vno;
}

/*
 * For PCI devices with irq 0, we assume the PIR table is incomplete
 * and attempt MSI.  If MSI succeeds, we will choose a vector.
 * Always return -1 or the chosen vector number.
 */
int
mpintrenable(Vctl* v)
{
	int irq, tbdf, vno;

	/*
	 * If the bus is known, try it.
	 * BUSUNKNOWN is given both by [E]ISA devices and by
	 * interrupts local to the processor (local APIC, coprocessor
	 * breakpoint and page-fault).
	 */
	tbdf = v->tbdf;
	if(tbdf != BUSUNKNOWN && (vno = mpintrenablex(v, tbdf)) != -1)
		return vno;

	irq = v->irq;
	if(irq >= IrqLINT0 && irq <= MaxIrqLAPIC){
		if(irq != IrqSPURIOUS)
			v->isr = lapiceoi;  /* dismiss interrupt at isr start */
		return VectorPIC+irq;
	}
	if(irq < 0 || irq > MaxIrqPIC){
		print("mpintrenable: irq %d out of range\n", irq);
		return -1;
	}

	/*
	 * Either didn't find it or have to try the default buses
	 * (ISA and EISA). This hack is due to either over-zealousness
	 * or laziness on the part of some manufacturers.
	 */
	vno = -1;
	if(mpisabus != -1)
		vno = mpintrenablex(v, MKBUS(BusISA, 0, 0, 0));
	if(Expprnochoice && vno < 0)
		print("mpintrenable: out of choices isa %d tbdf %T irq %d\n",
			mpisabus, v->tbdf, v->irq);
	return vno;
}

/*
 * secondary cpus should all idle (here or in shutdown, called from reboot).
 * for a true shutdown, reset and boot, cpu 0 should then reset itself or the
 * system as a whole.  if plan 9 is rebooting (loading a new kernel and
 * starting it), cpu 0 needs to keep running to do that work.
 */
void
mpshutdown(void)
{
	static QLock mpshutdownlock;

	if(m->machno == 0 && canqlock(&mpshutdownlock)) {  /* we are cpu0 */
		if(active.rebooting)
			return;
		print("mpshutdown: %d active cpus\n", active.nmachs);
		delay(1000);
		splhi();
		arch->resetothers();
		delay(1);			/* let secondary cpus reset */

		/* we can now use the uniprocessor reset */
		archreset();
	} else {			/* we are probably a secondary cpu */
		/*
		 * If this processor received the CTRL-ALT-DEL from
		 * the keyboard, acknowledge it. Send an INIT to self.
		 */
		/* should verify ctrl-alt-del handling */
		if(lapicisr(VectorPIC + IrqKBD)) {
			lapiceoi(VectorPIC + IrqKBD);
			iprint("cpu%d: ctrl-alt-del: sending self init\n",
				m->machno);
			delay(50);
			lapicicrw(0, LapicSELF|ApicINIT);
		}
		arch->introff();
	}
	idle();					/* no return */
}
